<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Graphiti</title>
  <meta name="description" content="Stylish Graph APIs">

  <link rel="stylesheet" href="https://graphiti-api.github.io/graphiti/assets/main.css?ref=wh4t3v45">
  <link rel="alternate" type="application/rss+xml" title="Graphiti" href="/feed.xml">

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-127904727-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-127904727-1');
  </script>

  <!-- javascript -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

  
</head>


  <body>
    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <header class="navbar navbar-inverse normal" role="banner">
  <div class="container">
    <div class="navbar-header">
      <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a href="https://graphiti-api.github.io/graphiti" class="navbar-brand">Graphiti</a>
    </div>
    <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
      <ul class="nav navbar-nav">
        <li>
          <a class="nav-link" href="https://graphiti-api.github.io/graphiti/quickstart">Quickstart</a>
        </li>
        <li>
          <a class="nav-link" href="https://graphiti-api.github.io/graphiti/guides">Guides</a>
        </li>
        <li>
          <a class="nav-link" href="https://graphiti-api.github.io/graphiti/tutorial">Tutorial</a>
        </li>
        <li>
          <a class="nav-link" href="https://graphiti-api.github.io/graphiti/js">Spraypaint</a>
        </li>
      </ul>
      <ul class="nav navbar-nav navbar-right visible-md visible-lg">
        <li>
          <a href="https://github.com/graphiti-api/graphiti" class="button">Fork on Github</a>
        </li>
      </ul>
    </nav>
  </div>
</header>

        <div class="container">
          <h1 id="why-graphiti">Why Graphiti</h1>

<p>I have enourmous respect for GraphQL. I also believe there is a
fundamental flaw in its design.</p>

<p>Let’s remember <a href="https://dev.to/smizell/why-people-like-graphql-221c">why people like GraphQL</a> in the first place: because it addressed common frustrations with REST APIs:</p>

<blockquote>
  <p><em>[We] heard from integrators that our REST API also wasn’t very flexible. It sometimes required two or three separate calls to assemble a complete view of a resource. It seemed like our responses simultaneously sent too much data and didn’t include data that consumers needed.</em></p>

  <p>- <a href="https://githubengineering.com/the-github-graphql-api">“The Github Graph API”</a>, GitHub Engineering</p>
</blockquote>

<p>GraphQL solves real problems. It’s flaw is that it solved these
problems using zero-sum thinking: we must
abandon the existing paradigm and forge a new one. It’s GraphQL
versus REST, one or the other. <a href="https://medium.freecodecamp.org/rest-apis-are-rest-in-peace-apis-long-live-graphql-d412e559d8e4">REST is dead, long live GraphQL</a>.</p>

<p>Graphiti instead approaches the problem using <a href="http://aturon.github.io/2018/06/02/listening-part-2">positive-sum thinking</a>:</p>

<blockquote>
  <p><em>Positive-sum thinking is how we embrace pluralism while retaining a coherent vision and set of values…A zero-sum view would assume that apparent oppositions are fundamental, e.g., that appealing to the JS crowd inherently hurts the C++ one. A positive-sum view starts by seeing different perspectives and priorities as legitimate and worthwhile, with a faith that</em> <strong>by respecting each other in this way, we can find strictly better solutions than had we optimized solely for one perspective.</strong></p>

  <p>- <a href="http://aturon.github.io/2018/06/02/listening-part-2">“Listening and Trust”</a>, Aaron Turon</p>
</blockquote>

<p>GraphQL optimized around REST’s shortcomings, and in doing so it dropped
REST’s advantages. There is no need for such a zero-sum tradeoff. We can take
everything great about GraphQL and build it <strong><em>on top of</em></strong> REST (and
HTTP!), instead of replacing it altogether. We can have our cake and eat it too.</p>

<h2 id="rest">REST</h2>

<p>Many GraphQL posts define REST like so:</p>

<p><br /></p>

<p align="center">
  <img width="80%" src="https://user-images.githubusercontent.com/55264/52901666-6a6f0800-31d4-11e9-81be-4bc23a7c26aa.png" />
</p>

<p><br /></p>

<p>It’s true that many REST APIs work this way, but this is not REST. While there’s
endless debate around which APIs are considered “RESTful”, I don’t think
we need to look much further than what the letters actually stand for:</p>

<blockquote>
  <p><strong>Representational State Transfer</strong>. <em>This sentence is not only what REST stands for, it is also the tiniest possible description of what REST actually means…It is not a standard, rather a style describing the act of transfering a state of something by its representation.</em></p>

  <p><em>Lets consider this:</em></p>

  <p><em>Marcus is a farmer. He has a ranch with 4 pigs, 12 chickens and 3 cows. He is now simulating a REST api while i am the client. If i want to request the current state of his farm using REST i just ask him: “State?”</em></p>

  <p><em>Marcus answers: “4 pigs, 12 chickens, 3 cows”.
This is the most simple example of Representional State Transfer. Marcus transfered the state of his farm to me using a representation. The representation of the farm is the plain sentence: “4 pigs, 12 chickens, 3 cows”.</em></p>

  <p><em>So lets get to the next level. How would i tell Marcus to add 2 cows to his farm the REST way?
Maybe tell him: “Marcus, please add 2 cows to your farm”.</em></p>

  <p><em>Do you think this was REST? Are we transfering state by its representation here? NO! This was calling a remote procedure. The procedure of adding 2 cows to the farm.</em></p>

  <p><em>Marcus sadly answers: “400, Bad Request. What do you mean?”</em></p>

  <p><em>So lets try this again. How would we do this the REST way? What was the representation again? It was “4 pigs, 12 chickens, 3 cows”. Ok. so lets try this again transfering the representation…</em></p>

  <p><em>me: “Marcus, … 4 pigs, 12 chickens, 5 cows … please!”.</em>
<em>Marcus: “Alright !”.</em>
<em>me: “Marcus, … what is your state now?”.</em>
<em>Marcus: “4 pigs, 12 chickens, 5 cows”.</em>
<em>me: “Ahh, great!”</em>
<em>See? It was really not that hard and it was REST.</em></p>

  <p>- <a href="http://www.beabetterdeveloper.com/2013/07/why-rest-is-so-important.html">“Why REST Is So Important”</a>, Gregor Riegler</p>
</blockquote>

<p>In other words, <strong>this is REST</strong>:</p>

<p align="center">
  <img width="50%" src="https://user-images.githubusercontent.com/55264/52913247-36561e80-328a-11e9-98ea-5e743920d317.gif" />
</p>

<p>We’re moving an object from the server to the client, possibly modifying
that object, then moving back to the server.</p>

<p>Pretty simple right? Here’s how we might implement this in GraphQL:</p>

<figure class="highlight"><pre><code class="language-typescript" data-lang="typescript"><span class="kd">type</span> <span class="nx">CreateEmployeeInput</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="nb">String</span>
  <span class="nl">age</span><span class="p">:</span> <span class="nx">Int</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">CreateEmployeePayload</span> <span class="p">{</span>
  <span class="nl">employee</span><span class="p">:</span> <span class="nx">Employee</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">UpdateEmployeeInput</span> <span class="p">{</span>
  <span class="nl">employeeId</span><span class="p">:</span> <span class="nx">ID</span><span class="o">!</span>
  <span class="nx">name</span><span class="err">:</span> <span class="nb">String</span>
  <span class="nl">age</span><span class="p">:</span> <span class="nx">Int</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">UpdateEmployeePayload</span> <span class="p">{</span>
  <span class="nl">employee</span><span class="p">:</span> <span class="nx">Employee</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">DestroyEmployeeInput</span> <span class="p">{</span>
  <span class="nl">id</span><span class="p">:</span> <span class="nx">ID</span><span class="o">!</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">DestroyEmployeePayload</span> <span class="p">{</span>
  <span class="nl">employee</span><span class="p">:</span> <span class="nx">Employee</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Employee</span> <span class="p">{</span>
  <span class="nl">id</span><span class="p">:</span> <span class="nx">ID</span><span class="o">!</span>
  <span class="nx">name</span><span class="err">:</span> <span class="nb">String</span>
<span class="p">}</span>

<span class="nx">createEmployee</span><span class="p">(</span><span class="nx">input</span><span class="err">:</span> <span class="nx">CreateEmployeeInput</span><span class="o">!</span><span class="p">)</span><span class="err">:</span> <span class="nx">CreateEmployeePayload</span>
<span class="nx">updateEmployee</span><span class="p">(</span><span class="nx">input</span><span class="err">:</span> <span class="nx">UpdateEmployeeInput</span><span class="o">!</span><span class="p">)</span><span class="err">:</span> <span class="nx">UpdateEmployeePayload</span>
<span class="nx">destroyEmployee</span><span class="p">(</span><span class="nx">input</span><span class="err">:</span> <span class="nx">DestroyEmployeeInput</span><span class="o">!</span><span class="p">)</span><span class="err">:</span> <span class="nx">DestroyEmployeePayload</span>

<span class="nx">employee</span><span class="p">(</span><span class="nx">id</span><span class="err">:</span> <span class="nx">ID</span><span class="o">!</span><span class="p">)</span><span class="err">:</span> <span class="nx">Employee</span></code></pre></figure>

<p>The first things to note is that GraphQL is super badass at describing
fields and types. The next thing to note is that fields and types are
the wrong abstraction.</p>

<p>Defining a schema like this allows bespoke, fine-grained detail. If we
wanted, the <code class="highlighter-rouge">CreateEmployeePayload</code> could be different than the
<code class="highlighter-rouge">UpdateEmployeePayload</code> - same for inputs like <code class="highlighter-rouge">CreateEmployeeInput</code> and
<code class="highlighter-rouge">UpdateEmployeeInput</code>. If we wanted other actions, like
<code class="highlighter-rouge">promoteEmployee</code> or <code class="highlighter-rouge">deactivateEmployee</code>, they would be easy to add and
follow the same basic constructs.</p>

<p>This is RPC - hand-crafted, custom requests. We have a high level of
<strong>configuration</strong> but a low level of <strong>convention</strong>. Not only will
developers have to spend more time hand-crafting these requests, but
patterns are likely to diverge from one API to the next, from team to
team, as time moves on. In fact, the above is really a best-case
scenario with common naming convention of <code class="highlighter-rouge">create/update/destroy</code> - the
Github API adds verbs like <code class="highlighter-rouge">add</code>, <code class="highlighter-rouge">remove</code>, <code class="highlighter-rouge">lock</code>, <code class="highlighter-rouge">move</code> and more.</p>

<p>The benefit of REST over RPC is conventions. Conventions cause increased
productivity and consistency (leading to fewer misunderstandiings and
chances for bugs). Let’s start thinking in REST, and see where it takes
us.</p>

<p>In REST, we know the input and output is always the Resource:</p>

<figure class="highlight"><pre><code class="language-typescript" data-lang="typescript"><span class="kd">type</span> <span class="nx">Employee</span> <span class="p">{</span>
  <span class="nl">id</span><span class="p">:</span> <span class="nx">ID</span><span class="o">!</span>
  <span class="nx">name</span><span class="err">:</span> <span class="kr">string</span>
<span class="p">}</span>

<span class="nx">createEmployee</span><span class="p">(</span><span class="nx">input</span><span class="err">:</span> <span class="nx">Employee</span><span class="p">)</span><span class="err">:</span> <span class="nx">Employee</span>
<span class="nx">updateEmployee</span><span class="p">(</span><span class="nx">input</span><span class="err">:</span> <span class="nx">Employee</span><span class="o">!</span><span class="p">)</span><span class="err">:</span> <span class="nx">Employee</span>
<span class="nx">destroyEmployee</span><span class="p">(</span><span class="nx">input</span><span class="err">:</span> <span class="nx">Employee</span><span class="o">!</span><span class="p">)</span><span class="err">:</span> <span class="nx">Employee</span>

<span class="nx">employee</span><span class="p">(</span><span class="nx">id</span><span class="err">:</span> <span class="nx">ID</span><span class="p">)</span><span class="err">:</span> <span class="nx">Employee</span></code></pre></figure>

<p>OK, a little tighter. But there’s actually no reason to type this out
each time - we can assume developers are already familiar with the
convention.</p>

<figure class="highlight"><pre><code class="language-typescript" data-lang="typescript"><span class="kd">type</span> <span class="nx">Employee</span> <span class="p">{</span>
  <span class="nl">id</span><span class="p">:</span> <span class="nx">ID</span><span class="o">!</span>
  <span class="nx">name</span><span class="err">:</span> <span class="kr">string</span>
<span class="p">}</span>

<span class="nx">createEmployee</span>
<span class="nx">updateEmployee</span>
<span class="nx">destroyEmployee</span>

<span class="nx">employee</span><span class="p">(</span><span class="nx">id</span><span class="err">:</span> <span class="nx">ID</span><span class="p">)</span></code></pre></figure>

<p>Getting there. OK and we know we’re dealing with an Employee, and we
know we won’t have custom verbs like <code class="highlighter-rouge">promote</code> or <code class="highlighter-rouge">remove</code>.</p>

<figure class="highlight"><pre><code class="language-typescript" data-lang="typescript"><span class="kd">type</span> <span class="nx">Employee</span> <span class="p">{</span>
  <span class="nl">id</span><span class="p">:</span> <span class="nx">ID</span><span class="o">!</span>
  <span class="nx">name</span><span class="err">:</span> <span class="kr">string</span>
<span class="p">}</span>

<span class="nx">create</span>
<span class="nx">update</span>
<span class="nx">destroy</span>
<span class="nx">show</span> <span class="c1">// employee(id: ID)</span>
<span class="nx">index</span> <span class="c1">// employee()</span></code></pre></figure>

<p>By adopting conventions, we not only removed boilerplate - we removed
the chance of subtle inconsistencies. This is better for both providers
and consumers of the API.</p>

<p>We’re just getting started.</p>

<p>The above schema covers basic CRUD. But we probably want to filter data, right? Let’s say we want to return all employees with a given name:</p>

<figure class="highlight"><pre><code class="language-typescript" data-lang="typescript"><span class="nx">employee</span><span class="p">(</span><span class="nx">id</span><span class="err">:</span> <span class="nx">ID</span><span class="p">,</span> <span class="nx">name</span><span class="err">:</span> <span class="nb">String</span><span class="p">)</span></code></pre></figure>

<p>Again, we’re seeing chances for inconsistency. What’s the <code class="highlighter-rouge">name</code>
parameter - straight equality? Case sensitive? Contains? I guess we
could throw a bunch of suffixes at it:</p>

<figure class="highlight"><pre><code class="language-typescript" data-lang="typescript"><span class="nx">employee</span><span class="p">(</span><span class="nx">id</span><span class="err">:</span> <span class="nx">ID</span><span class="p">,</span> <span class="nx">name_eq</span><span class="err">:</span> <span class="nb">String</span><span class="p">,</span> <span class="nx">name_suffix</span><span class="err">:</span> <span class="nb">String</span><span class="p">,</span> <span class="nx">name_prefix</span><span class="err">:</span>
<span class="nb">String</span><span class="p">,</span> <span class="nx">name_contains</span><span class="err">:</span> <span class="nb">String</span><span class="p">,</span> <span class="nx">name_not_eq</span><span class="err">:</span> <span class="nb">String</span><span class="p">,</span> <span class="nx">name_not_suffix</span><span class="err">:</span>
<span class="nb">String</span><span class="p">,</span> <span class="nx">name_prefix</span><span class="err">:</span> <span class="nb">String</span><span class="p">,</span> <span class="nx">name_not_prefix</span><span class="err">:</span> <span class="nb">String</span><span class="p">)</span></code></pre></figure>

<p>Works, but a bit unwieldy…and again, likely to diverge wildly across
implementations.</p>

<p>What about sorting? Should we do it similar to the Github API?:</p>

<figure class="highlight"><pre><code class="language-typescript" data-lang="typescript"><span class="kr">enum</span> <span class="nx">OrderDirection</span> <span class="p">{</span>
  <span class="nx">ASC</span>
  <span class="nx">DESC</span>
<span class="p">}</span>

<span class="kr">enum</span> <span class="nx">EmployeeOrderField</span> <span class="p">{</span>
  <span class="nx">ID</span>
  <span class="nx">NAME</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">EmployeeOrder</span> <span class="p">{</span>
  <span class="nl">field</span><span class="p">:</span> <span class="nx">EmployeeOrderField</span><span class="o">!</span>
  <span class="nx">direction</span><span class="err">:</span> <span class="nx">OrderDirection</span>
<span class="p">}</span>

<span class="nx">employee</span><span class="p">(</span><span class="nx">orderBy</span><span class="err">:</span> <span class="nx">EmployeeOrder</span><span class="p">)</span></code></pre></figure>

<p>Or should we do it like <a href="https://www.howtographql.com/graphql-js/8-filtering-pagination-and-sorting/">How to
GraphQL</a>?:</p>

<figure class="highlight"><pre><code class="language-typescript" data-lang="typescript"><span class="kr">enum</span> <span class="nx">EmployeeOrderByInput</span> <span class="p">{</span>
  <span class="nx">id_ASC</span>
  <span class="nx">id_DESC</span>
  <span class="nx">name_ASC</span>
  <span class="nx">name_DESC</span>
<span class="p">}</span>

<span class="nx">employee</span><span class="p">(</span><span class="nx">orderBy</span><span class="err">:</span> <span class="nx">EmployeeOrderByInput</span><span class="p">)</span></code></pre></figure>

<p>We have divergent APIs right off the bat, and neither one supports
multisort.</p>

<p>Let’s take a step back and think RESTfully. REST doesn’t have a query
specification, but it does have this Resource concept. <strong>Instead of
thinking in fields and types, what if we thought in Resources</strong>?:</p>

<p>Resources have attributes (fields) with corresponding types (String, Int, etc). We’d
probably want to filter and sort by these attributes right? We might add
some additional filters and sorts, we might want to opt-out of others,
but it makes a reasonable baseline to query a Resource by its
attributes.</p>

<p>If we have an attribute and it’s a <code class="highlighter-rouge">string</code>, we know we’re
talking about operators like <code class="highlighter-rouge">suffix</code> and <code class="highlighter-rouge">prefix</code>, but an <code class="highlighter-rouge">integer</code>
attribute would want operators like <code class="highlighter-rouge">greater_than</code> and <code class="highlighter-rouge">less_than</code>.</p>

<p>OK, so really we don’t need to define <em>inputs</em> and <em>outputs</em> - those can
be assumed by convention. What we really need to define is the Resource.</p>

<p>Welcome to Graphiti:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">EmployeeResource</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">attribute</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:string</span><span class="p">,</span> <span class="ss">sortable: </span><span class="kp">true</span><span class="p">,</span> <span class="ss">filterable: </span><span class="kp">true</span>
  <span class="n">attribute</span> <span class="ss">:age</span><span class="p">,</span> <span class="ss">:integer</span><span class="p">,</span> <span class="ss">writable: </span><span class="kp">false</span>
<span class="k">end</span></code></pre></figure>

<p>With nothing but this Resource definition and some assumed conventions,
we get all this behavior out of the box:</p>

<ul>
  <li>Create</li>
  <li>Update</li>
  <li>Delete</li>
  <li>Read
    <ul>
      <li>Filter
        <ul>
          <li>String (<code class="highlighter-rouge">name</code>)
            <ul>
              <li><code class="highlighter-rouge">eq</code> (case sensitive)</li>
              <li><code class="highlighter-rouge">eql</code> (case insensitive)</li>
              <li><code class="highlighter-rouge">prefix</code></li>
              <li><code class="highlighter-rouge">suffix</code></li>
              <li><code class="highlighter-rouge">match</code></li>
              <li><code class="highlighter-rouge">not_*</code> (<code class="highlighter-rouge">not_eq</code>, <code class="highlighter-rouge">not_prefix</code>, etc)</li>
            </ul>
          </li>
          <li>Dates and Numbers (<code class="highlighter-rouge">age</code>)
            <ul>
              <li><code class="highlighter-rouge">eq</code></li>
              <li><code class="highlighter-rouge">gt</code> (greater than)</li>
              <li><code class="highlighter-rouge">lt</code> (less than)</li>
              <li><code class="highlighter-rouge">gte</code> (greater than/equal to)</li>
              <li><code class="highlighter-rouge">lte</code> (less than/equal to)</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Sort / Multisort</li>
      <li>Paginate</li>
      <li>Fieldsets</li>
    </ul>
  </li>
</ul>

<p>There’s more to this than a bunch of out-of-the-box standards and
behavior. If we thought only in Fields and Types, we’d use GraphiQL to
see something like:</p>

<p><br /></p>

<p align="center">
  <img width="30%" src="https://user-images.githubusercontent.com/55264/52915902-78418d80-32a7-11e9-8515-021312258400.png" />
</p>

<p><br /></p>

<p>But if we thought in Resources…well, REST is super popular for
websites, websites have forms, so what if we:</p>

<p><br /></p>

<p align="center">
  <img width="30%" src="https://user-images.githubusercontent.com/55264/52916024-e3d82a80-32a8-11e9-8bb6-07ac9bf988dc.png" />
</p>

<p><br /></p>

<p>This screenshot is from <a href="https://graphiti-api.github.io/graphiti/guides/vandal">Vandal</a>, the Graphiti UI.</p>

<p>Because we started with a better abstraction, we ended with a better
visualization. As a marketer-turned-programmer myself, I really
appreciate when data exploration tools like this are friendly to
less-technical users. I like that my product owner and I can walk
through the domain together, validating concepts and solidifying a shared
understanding. A user of Vandal doesn’t need to know about <code class="highlighter-rouge">Connection</code>s
or <code class="highlighter-rouge">Edge</code>s, they just need to click around.</p>

<p>We even get schema benefits. Schemas are great for tooling and
backwards-compatibility checks…but when they are oriented around
Fields and Types, they can only tell you so much. When they are oriented
around Resources, they can expose less-obvious concepts. Maybe we sort
Employees by <code class="highlighter-rouge">created_at</code> by default:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="o">{</span>
  <span class="s2">"name"</span>: <span class="s2">"EmployeeResource"</span>,
  <span class="s2">"type"</span>: <span class="s2">"employees"</span>,
  <span class="s2">"attributes"</span>: <span class="o">{</span> ... <span class="o">}</span>,
  <span class="s2">"default_sort"</span>: <span class="o">[{</span> <span class="s2">"created_at"</span>: <span class="s2">"desc"</span> <span class="o">}]</span>,
  ...
<span class="o">}</span></code></pre></figure>

<p>Because this is specified in the schema, not only are clients more
informed but changing this default could raise a backwards-compatibility
error:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">EmployeeResource: default sort changed from <span class="o">[{</span>:created_at<span class="o">=</span>&gt;<span class="s2">"desc"</span><span class="o">}]</span> to <span class="o">[{</span>:last_name<span class="o">=</span>&gt;<span class="s2">"asc"</span><span class="o">}]</span>.</code></pre></figure>

<p>Relationships at some point?
schema stitching.</p>

<ul>
  <li>backwards compat sort</li>
</ul>

<p>then schema stiching</p>

<p>https://twitter.com/sarahmei/status/702281663896653824</p>

<p>Why do we have to spell
this out each time? This can lead to subtle inconsistencies, both within
this project and across other projects.</p>
<ul>
  <li>Same for the input.</li>
  <li></li>
</ul>

<p>changeUserStatus(input: ChangeUserStatusInput!): ChangeUserStatusPayload</p>

<p>addPullRequestReview(input: AddPullRequestReviewInput!): AddPullRequestReviewPayload</p>

<p>submitPullRequestReview(input: SubmitPullRequestReviewInput!): SubmitPullRequestReviewPayload</p>

<p>deletePullRequestReview(input: DeletePullRequestReviewInput!): DeletePullRequestReviewPayload</p>

<p>Those objects are connected, and together those connections form a
<strong>graph</strong>. REST allows you to lazy-load that graph using URL links:</p>

<p>In other words, <strong>REST is optimized for lazy-loading</strong>. REST is great at A) supplying conventions that will lead to cleaner object-oriented code B) lazy-loading data C) caching.</p>

<p>REST is incredibly powerful, well-understood, and well-supported. We
don’t need to get rid of REST. We need to add <strong>eager loading</strong>:</p>

<p>[TODO EAGER]</p>

<blockquote>
  <p>19:35 *Having that level of consistency, and working with that for
just a little while means that you can start to forget about it. And
that’s the power of conventions in general…it used to be something
you had to think about and make a decision. Well, decisions are bad.
Decisions take up your brain power, and it requires brain cycles to
consider which or the other. The more decisions you can take out of
the whole thing, the more brain power you can free up to consider the
really important things.</p>
</blockquote>

<blockquote>
  <p>If everybody is doing the same thing in the same way, it means that
you can easily go from one application to the other, and expect the
same things to happen.</p>

  <p>- <a href="https://www.youtube.com/watch?v=GFhoSMD6idk">“Resources on Rails”</a>, David Heinemeier Hansson</p>
</blockquote>

<p>This first, on simplicity and conventions:</p>

<p>There is simply no need for this:</p>

<ul>
  <li>submit, add, unlock</li>
  <li>the input is a <code class="highlighter-rouge">PullRequestReview</code></li>
  <li>the output is a <code class="highlighter-rouge">PullRequestReview</code></li>
</ul>

<p>submitPullRequestReview(input: SubmitPullRequestReviewInput!): SubmitPullRequestReviewPayload</p>

<p>REST would say: just tell me about your Pull Request. I already know how
to CRUD it, so just tell me what it is.</p>

<p>Edges and Connections</p>

<p>class PullRequestResource
end</p>

<ul>
  <li>Create read update delete</li>
</ul>

<p>add</p>

<p>has_many :comments</p>

<p>CRUD comments, disassociate</p>

<p>Let’s see what else we can do.</p>

<p>Because resource with attributes, and attributes have types, we can
infer filters - prefix and suffix, greater than less than.</p>

<p>Our schema doesn’t need to define inputs and outputs - REST already
tells us what those are. So, what we need to define are Resources,
marking attributes writable readable etc</p>

<p>Because query interface, schema stitching.</p>

<p>Just as REST gives us constraints, for saving, thinking about resources
gives us contraints for querying. Resources have attributes, and we’ll
want to filter and sort on those attributes. We’ll need to paginate, and
maybe add statistics. That’s it.</p>

<p>show it all, and say all this was possible because we started with a
simple concept, one that’s been around forever and powers much of the
web today. When solving problems, we should build on existing solutions
and embrase positive-sum thinking.</p>

<p>When we add conventions, great things happen. That doesn’t mean
conventions are “what works with activerecord” - conventions must be
informed by diverse opinions and perspectives. But still, arriving at
one way to do things is the sweet spot.</p>

<p>Core value: Common conventions informed by diverse perspectives</p>

        </div>
      </div>
    </main>
    <div class="main-footer main-footer--dark">
  <div class="container">
    <div class="row">
      <div class="col-sm-4 menu">
        <h3>Overview</h3>
        <ul>
          <li>
            <a href="https://graphiti-api.github.io/graphiti/quickstart">Quickstart</a>
          </li>
          <li>
            <a href="https://graphiti-api.github.io/graphiti/tutorial">Tutorial</a>
          </li>
          <li>
            <a href="https://graphiti-api.github.io/graphiti/guides">Guides</a>
          </li>
        </ul>
      </div>
      <div class="col-sm-4 menu">
        <h3>Contact</h3>
        <ul>
          <li>
            <a target="_blank" href="https://join.slack.com/t/graphiti-api/shared_invite/enQtMjkyMTA3MDgxNTQzLWVkMDM3NTlmNTIwODY2YWFkMGNiNzUzZGMzOTY3YmNmZjBhYzIyZWZlZTk4YmI1YTI0Y2M0OTZmZGYwN2QxZjg">Slack Chat</a>
          </li>
          <li>
            <a href="mailto:richmolj@gmail.com">Email</a>
          </li>
        </ul>
      </div>
      <div class="col-sm-4 menu">
        <h3>Related</h3>
        <ul>
          <li>
            <a target="_blank" href="http://jsonapi.org">JSONAPI Spec</a>
          </li>
          <li>
            <a target="_blank" href="http://jsonapi-rb.org">jsonapi-rb</a>
          </li>
          <li>
            <a target="_blank" href="https://vuejs.org/">VueJS</a>
          </li>
        </ul>
      </div>
    </div>
  </div>
</div>

    <script type="text/javascript">
$(function () {

  var flipTabs = function() {
    var isTS = true;
    if (localStorage.getItem('js-lang') === 'javascript') {
      isTS = false;
    }

    $('.code-tabs').each(function(index, el) {
      if (isTS) {
        console.log('hiding js');
        $($(el).children()[1]).hide();
        $($(el).children()[0]).show();
      } else {
        console.log('hiding ts');
        $($(el).children()[0]).hide();
        $($(el).children()[1]).show();
      }
    });

    if (isTS) {
      $('.tab.typescript').addClass('active');
      $('.tab.javascript').removeClass('active');
    } else {
      $('.tab.typescript').removeClass('active');
      $('.tab.javascript').addClass('active');
    }
  }

  $('.tab').click(function() {
    if ($(this).hasClass('typescript')) {
      localStorage.setItem('js-lang', 'typescript');
    } else {
      localStorage.setItem('js-lang', 'javascript');
    }

    flipTabs();
  });

  flipTabs();
})
</script>

  </body>
</html>
